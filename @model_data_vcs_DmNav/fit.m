function a_md = fit(a_md, title_str, props)

% fit - Fit model to data.
%
% Usage:
% a_md = fit(a_md, title_str, props)
%
% Parameters:
%   a_md: A model_data_vcs_DmNav object.
%   props: A structure with any optional properties.
%     fitRange: Start and end times of range to apply the optimization [ms].
%     fitRangeRel: Start and end times of range relative to first voltage
%     		   step [ms]. Specify any other voltage step as the first element.
%     fitLevels: Indices of voltage/current levels to use from clamp
%     		 data. If empty, not fit is done.
%     dispParams: If non-zero, display params every once this many iterations.
%     dispPlot: If non-zero, update a plot of the fit at end of this many iterations.
%     quiet: If 1, do not include cell name on title.
% 
% Returns:
%   a_md: Updated model_data_vcs_DmNav object with fit.
%
% Description:
%
% Example:
% >> a_md = ...
%    fit(a_md, '', ...
%      struct('fitRangeRel', [-.2 165], 'fitLevels', 1:5, ...
%             'dispParams', 5, ...
%             'optimset', struct('Display', 'iter')));
%
% See also: param_I_v, param_func
%
% $Id$
%
% Author: Cengiz Gunay <cgunay@emory.edu>, 2010/10/12

% TODO: 
% - separate plotting to other methods (including dispPlot)
% - remove title_str parameter
% - process 2nd step and write a 2nd data file for prepulse step
% - prepare a doc_multi from this. Find a way to label figures but print later.
% - also plot IClCa m_infty curve?
% - have option to show no plots, to create database of params
% - extract fitting to a separate function that returns the optimized _f

props = defaultValue('props', struct);
title_str = defaultValue('title_str', '');

data_vc = a_md.data_vc;
dt = get(data_vc, 'dt') * 1e3;             % convert to ms
cell_name = get(a_md, 'id');

time = (0:(size(a_md.data_vc.v.data, 1) - 1)) * dt;

% select the initial part before v-dep currents get activated
range_rel = getFieldDefault(props, 'fitRangeRel', []); % [ms]

if ~ isempty(range_rel)
  if length(range_rel) > 2
    step_num = range_rel(1);
    range_rel = range_rel(2:end);
  else
    step_num = 1;
  end
  % if relative, calc from step times
  range_maxima = ...
      period([data_vc.time_steps(step_num) + ...
              floor(range_rel / dt + .49)]);
else
  % take the whole range
  range_maxima = periodWhole(data_vc);
end

% overwrite if...
if isfield(props, 'fitRange')
  range_maxima = period(round(props.fitRange / dt));
end

range_cap_resp = round(range_maxima.start_time):round(range_maxima.end_time);

% use all voltage levels by default
use_levels = getFieldDefault(props, 'fitLevels', 1:size(data_vc.v.data, 2));

% func
f_model = a_md.model_f;

extra_text = ...
    [ '; fit ' get(f_model, 'id') ' to [' ...
      sprintf('%.2f ', [range_maxima.start_time range_maxima.end_time] * dt) ']' ...
      '; levels: [' sprintf('%d ', use_levels) '], ' ...
      getParamsString(f_model) ];

if isfield(props, 'quiet')
  all_title = properTeXLabel(title_str);
else
  all_title = ...
      properTeXLabel([ cell_name ': Raw data' extra_text title_str ]);
end

if isfield(props, 'dispParams')
  props = ...
      mergeStructsRecursive(...
        props, ...
        struct('optimset', optimset('OutputFcn', @disp_out)));
end

if isfield(props, 'dispPlot') && props.dispPlot > 0
  props = ...
      mergeStructsRecursive(...
        props, ...
        struct('optimset', optimset('OutputFcn', @plot_out)));      
end

% need to run optimset at least once to get all the fields
props = ...
    mergeStructsRecursive(props, struct('optimset', optimset));      


line_colors = lines(length(use_levels)); %hsv(length(v_steps));

  function stop = disp_out(x, optimValues, state)
    if mod(optimValues.iteration, props.dispParams) == 0 && ...
          strcmp(state, 'iter')
      disp(displayParams(setParams(f_model, x, struct('onlySelect', 1)), ...
                         struct('lastParamsF', f_model, ...
                                'onlySelect', 1)));
    end
    stop = false;
  end

  fig_props = struct;
  
  function stop = plot_out(p, optimValues, state)
  % TODO: use existing plot functions and make this refresh by a parallel
  % worker so can be seen during fitting process
    if mod(optimValues.iteration, props.dispPlot) == 0  && ...
          strcmp(state, 'iter')
      f_model = setParams(f_model, p, struct('onlySelect', 1));
      Im = f(f_model, struct('v', data_vc.v.data(range_cap_resp, use_levels), 'dt', dt));
      fig_handle = ...
          plotFigure(...
            plot_stack({...
              plot_superpose({...
                plot_abstract({time(range_cap_resp), ...
                          data_vc.i.data(range_cap_resp, use_levels)}, ...
                              {'time [ms]', 'I [nA]'}, ...
                              'fitted currents', {}, 'plot', ...
                              struct('ColorOrder', line_colors, ...
                                     'noLegends', 1)), ...
                plot_abstract({time(range_cap_resp), Im}, ...
                              {'time [ms]', 'I [nA]'}, ...
                              'est. I_{cap+leak}', {}, 'plot', ...
                              struct('plotProps', struct('LineWidth', 2), ...
                                     'ColorOrder', line_colors))}, ...
                             {}, '', struct('noCombine', 1)), ...
              plot_abstract({time(range_cap_resp), ...
                          data_vc.v.data(range_cap_resp, use_levels)}, {'time [ms]', 'V_m [mV]'}, ...
                            'all currents', {}, 'plot', struct)}, ...
                       [min(range_cap_resp) * dt, max(range_cap_resp) * dt NaN NaN], ...
                       'y', all_title, ...
                       struct('titlesPos', 'none', 'xLabelsPos', 'bottom', ...
                              'fixedSize', [4 3], 'noTitle', 1)), '', ...
            fig_props);
      fig_props = mergeStructs(struct('figureHandle', fig_handle), fig_props);
    end
    stop = false;
  end

  % list of voltage steps for labeling
  v_steps = data_vc.v_steps(2, :);
  v_legend = ...
      cellfun(@(x)([ sprintf('%.0f', x) ' mV']), num2cell(v_steps'), ...
              'UniformOutput', false);

  params = getParamsStruct(f_model);

if ~ isempty(use_levels)
  disp('Fitting...');

  % save before optimization
  f_model_orig = f_model;
  
  % optimize
  f_model = ...
      optimize(f_model, ...
               struct('v', data_vc.v.data(range_cap_resp, use_levels), 'dt', dt), ...
               data_vc.i.data(range_cap_resp, use_levels), ...
               props);

  % recreate title text with new parameters
  extra_text = ...
    [ '; fit ' get(f_model, 'id') ' to [' ...
      sprintf('%.2f ', [range_maxima.start_time range_maxima.end_time] * dt) ']' ...
      '; levels: [' sprintf('%d ', use_levels) '], ' ...
      getParamsString(f_model) ];

  if isfield(props, 'quiet')
    all_title = properTeXLabel(title_str);
  else
    all_title = ...
        properTeXLabel([ cell_name ': Raw data' extra_text title_str ]);
  end

  % show all parameters (only the ones optimized)
  disp(displayParams(f_model, ...
                     struct('lastParamsF', f_model_orig, ...
                            'onlySelect', 1)));
  

  % nicely plot current and voltage trace in separate axes only for
  % part fitted
  
  % TODO: make this optional or remove completely
  
% $$$ Im = f(f_model, struct('v', data_vc.v.data(range_cap_resp, use_levels), 'dt', dt));  
% $$$ plotFigure(...
% $$$   plot_stack({...
% $$$     plot_superpose({...
% $$$         plot_abstract({time(range_cap_resp), ...
% $$$                     data_vc.i.data(range_cap_resp, use_levels)}, ...
% $$$                       {'time [ms]', 'I [nA]'}, ...
% $$$                       'fitted currents', {}, 'plot', ...
% $$$                       struct('ColorOrder', line_colors, ...
% $$$                              'noLegends', 1)), ...
% $$$         plot_abstract({time(range_cap_resp), Im}, ...
% $$$                       {'time [ms]', 'I [nA]'}, ...
% $$$                       'est. I_{cap+leak}', {}, 'plot', ...
% $$$                       struct('plotProps', struct('LineWidth', 2), ...
% $$$                              'ColorOrder', line_colors))}, ...
% $$$                      {}, '', struct('noCombine', 1)), ...
% $$$     plot_abstract({time(range_cap_resp), ...
% $$$                    data_vc.v.data(range_cap_resp, use_levels)}, {'time [ms]', 'V_m [mV]'}, ...
% $$$                   'all currents', {}, 'plot', struct)}, ...
% $$$              [min(range_cap_resp) * dt, max(range_cap_resp) * dt NaN NaN], ...
% $$$              'y', all_title, ...
% $$$              struct('titlesPos', 'none', 'xLabelsPos', 'bottom', ...
% $$$                     'fixedSize', [4 3], 'noTitle', 1)));

  % simulate new model here
  a_md = updateModel(a_md, f_model);

  plotFigure(plotDataCompare(a_md, all_title, ...
                             struct('levels', use_levels, ...
                                    'show', 'v', ...
                                    'axisLimits', [range_maxima.start_time * dt, range_maxima.end_time * dt NaN NaN])))

end


end
